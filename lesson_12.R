# Lesson 12: R Shiny Part One



# Hey everyone, this one is going to be a little different this post
# because I had to make a simple RShiny app today (they're never simple)
# and figured it might be a good place to start thinking about shiny apps. 

# Shiny is a web-based interface that uses bootstrap, a web design framework, 
# to allow for building user-interfaces for R, which means that any R code you can
# run in R studio can more or less be turned into a web application via Shiny. 

# you can also make more complex dashboards with shiny, but if I get to those
# ever it's going to be much later. 

# R shiny requires some comfort level with R, an additional unique way of 
# thinking about R called reactivity, and hopefully some comfort and 
# familiarity with HTML and CSS. If you're weak on any of those, Shiny
# isn't impossible, it's just harder. I believe in you. 


# There are myriad great resources for R shiny, including a subreddit r/rshiny
# and the never-ending-juggernaut that is https://shiny.rstudio.com/tutorial/

install.packages("shiny")



# A simplest R Shiny App looks like this: 


library(shiny) # today we are using only one library, and it has to go in every shiny app:

ui <- fluidPage(
  # all the user interface stuff goes here:
  # design, layout, user inputs, as well as 
  # any outputs for the user to see. 
)

server <- function(input, output, session) {
  # this function is the server, or the back end of your app. 
  # anything that moves or interacts, those movements or interactions are specified here
  # you can also store data here and call on other important features from R. 
  
}


# think of ui as the stuff the user sees and server as the stuff the user doesn't see. Simple. 

# you can run an app by running this code, but this app we just made is pretty boring. 
shinyApp(ui, server))


# for a very simple case, R Studio gives this as a basic shiny app: 

ui <- fluidPage(
  sliderInput(inputId = "bins",
              label = "Number of bins:",
              min = 1,
              max = 50,
              value = 30), # notice that within fluidpage() everything is separated by commas.
  plotOutput(outputId = "distPlot")
)
server <- function(input, output, session) {
  output$distPlot <- renderPlot({
    
    x    <- faithful$waiting # no commas necessary in server function. 
    bins <- seq(min(x), max(x), length.out = input$bins + 1) # see input$______ ? 
    
    hist(x, breaks = bins, col = "#75AADB", border = "white",
         xlab = "Waiting time to next eruption (in mins)",
         main = "Histogram of waiting times")
    
  })
}
shinyApp(ui, server)



# things to notice: 
# we have a whole new group of functions to learn, and they are distinguished by 
# camelCase (i.e. words, except the first, are distinguished by capital letters) 
# and they  tend to take the form of _____Input or ______Output. 

# values generated by the user become input$_____ values, and values that are
# generated by the backend become output$_______ values...this includes numbers, text,
# plots, etc. 

# this ui has two objects, a slider input with some arguments describing what it does, 
# and a plot output which references the server. On the server side, we have some 
# descriptions of data and binwidths (note how the user input goes in as an argument)
# and then a desription of the histogram. This'll possibly look unfamiliar because 
# we are used to plotting in ggplot2. ggplot2 does work well with rshiny; however, 
# in general ggplot2 takes longer to process than base r plotting, and becuase shiny
# reacts in real time to all user changes, that speed difference is noticeable. 
# therefore while ggplot2 is clearly superior to base r plotting in every single other
# way, this may be the exception. 


# -----------

# A slightly more complicated example. 

# today, I was asked to create a small shiny app that will store the winter, summer, spring
# and thanksgiving breaks and then give a days-between count that excludes those holidays, so
# e.g. if the input is the last day of spring semester and the second input is the first day 
# of fall semester, they only have 2 days between them despite the summer. 

# this example has a lot more moving parts than you'd expect. However, I'm going to include it
# here because A) I dislike how all the examples of shiny code are simplistic and give an 
# unrealistic expectation for what code looks like and B) my pedagogical philosophy says you should
# be exposed to examples that motivate you based on real applications
# rather than toys with boring, overused data sets. 


# Begin my app here:
ui <- shinyUI(
  fluidPage(
    # first, this is a layout feature. There are many layout features that only exist to structure
    # ui elements. This one just says put everything in a simple page. 

    h2("Calculate Date Ranges with School Holidays"),
    # h2 is the html tag for a 2nd level header
    box(
      # box is another within page element. providing additional structure. 
      # eventually this app goes into a shiny dashboard so in this case the box is just 
      # to format it against additional, as yet un-created elements in my bigger project. 
      dateRangeInput("dates", h3("Date Range"),
                     min = "2016-08-23" ,
                     max = "2022-05-13"),
      # four arguments here. First argument is what the input$_______ name will be (i.e. what goes where
      # that underscore now is). Second argument is what the user sees. Third and fourth specify
      # boundaries for the date range input. These boundaries exist because I don't need to go
      # further back in time than the fall 2016 semester and the fall 2022 semester hasn't been
      # published yet. 
      
      #date range input provides two dates as a 2-element list. We'll be subsetting it later. 
      textOutput(outputId = "dateRangeText"),
      # this will output some response text that I will define and label below. 
      
      tags$br(),
      tags$br(),
      # br is the html tag to add a line break. 
      tags$h3("About"),
      # h3 is html again. Why does it need tags$ this time and not above? A mystery to me; it probably
      # doesn't need it here at all but there you go. 
      tags$p("This application calculates the number of days (including weekends) between two selected dates.
             Times when [school] is not in session (summer and winter breaks between semesters) are excluded, as are
             Spring Break and Thanksgiving break."),
      # p is the tag for a paragraph in html, so this is just text explaining how to use
      # and interpret the app's output. 
      tags$p("Timelines are currently limited to Fall 2016 - Spring 2022 semesters.")
    ) #box
  ) # fluidpage
) #shinyUI

# these ending # things aren't necessary, but I find that in big complex apps
# or other kinds of code, they make edits much much much much easier. It's a good
# habit to get into now.

# if you've ever experienced trying to find the correct </div> in an html document
# without these, you know what I'm talking about. 

server <- function(input, output) {
  
  
  # okay, so I needed data for this app. Here the data are holiday breaks and times when the
  # school is in session. I pulled these from the university website by hand, so any mistakes
  # are my own. 
  
  # in a later version of the app, I'm considering using the package `rvest` to scrape the table
  # on the university's website for the relevant data, processing it in a separate document, then
  # source()ing that document to this one so that I don't have to still be here at the university 
  # in 2022 to update these data for the future users. This project has a long/indefinite timeline. 
  
  
  

  
  
  # Holidays List -------------------------------------------------------------------------------
  # notice how in r-studio this has a little triangle on the line number?
  # if you go in the top right of the scripting pane there's a toggle and you can use the 
  # text - - - - breaks as if they were headers. 
  
  # 2016-2017
  thanksgiving= c(  "2016-11-23", "2016-11-24", "2016-11-25", "2016-11-26", "2016-11-27")
  spring_break= c(  "2016-03-04", "2016-03-05", "2016-03-06", "2016-03-07", "2016-03-08", "2016-03-09", "2016-03-10", "2016-03-11", "2016-03-12")
  h2016 <-c(thanksgiving, spring_break )
  # 2017-2018
  thanksgiving= c(  "2017-11-22", "2017-11-23", "2017-11-24", "2017-11-25", "2017-11-26" )
  spring_break= c(  "2018-03-03", "2018-03-04", "2018-03-05", "2018-03-06", "2018-03-07", "2018-03-08", "2018-03-09", "2018-03-10", "2018-03-11")
  h2017 <-c(thanksgiving, spring_break )
  # 2018-2019
  thanksgiving= c(  "2018-11-21", "2018-11-22", "2018-11-23", "2018-11-24", "2018-11-25")
  spring_break= c(  "2019-03-09", "2019-03-10", "2019-03-11", "2019-03-12", "2019-03-13", "2019-03-14", "2019-03-15", "2019-03-16", "2019-03-17")
  h2018 <-c(thanksgiving, spring_break )
  # 2019-2020
  thanksgiving= c(  "2019-11-27", "2019-11-28", "2019-11-29", "2019-11-30", "2019-12-01")
  spring_break= c(  "2020-03-07", "2020-03-08", "2020-03-09", "2020-03-10", "2020-03-11", "2020-03-12", "2020-03-13", "2020-03-14", "2020-03-15")
  h2019 <-c(thanksgiving, spring_break )
  # 2020-2021
  thanksgiving= c(  "2020-11-25", "2020-11-26", "2020-11-27", "2020-11-28", "2020-11-29")
  spring_break= c(  "2020-03-06", "2020-03-07", "2020-03-08", "2020-03-09", "2020-03-10", "2020-03-11", "2020-03-12", "2020-03-13", "2020-03-14")
  h2020 <-c(thanksgiving, spring_break )
  # 2021-2022
  thanksgiving= c(  "2021-11-24", "2021-11-25", "2021-11-26", "2021-11-27", "2021-11-28")
  spring_break= c(  "2022-03-05", "2022-03-06", "2022-03-07", "2022-03-08", "2022-03-09", "2022-03-10", "2022-03-11", "2022-03-12", "2022-03-13")
  h2021 <-c(thanksgiving, spring_break )
  # notice how I am naming them the same thing every time? 
  # that might result in errors but if you think about it going in order, 
  # it doesn't matter if I'm renaming it every time because it runs efficiently in the R
  # studio paradigm -- the old data get erased in their sub-components but the 
  # h20__ data stays around until I call it later. 
  # In shiny, I'm not 100% sure that these run the way I want, so I am 
  # possibly inducing bugs by not labeling them all individually. Such is the cost of laziness.
  
  # full list: 
  holidays<-c(h2016,h2017,h2018,h2019,h2020,h2021)
  holidays<-as.Date(holidays, "%Y-%m-%d")

  
  # Semesters List --------------------------------------------------------------------------------
  fall2016    <- seq(as.Date("2016-08-23"), as.Date("2016-12-16"), by="days")
  # this time we can just specify the start and end date of each semester, then sequence along
  # it. The resulting data list is over 1,000 days long, so no need to ever call it. It just works. 
  spring2017  <- seq(as.Date("2017-01-18"), as.Date("2017-05-12"), by="days")
  fall2017    <- seq(as.Date("2017-08-22"), as.Date("2017-12-15"), by="days")
  spring2018  <- seq(as.Date("2018-01-17"), as.Date("2018-05-11"), by="days")
  fall2018    <- seq(as.Date("2018-08-28"), as.Date("2018-12-18"), by="days")
  spring2019  <- seq(as.Date("2019-01-14"), as.Date("2019-05-10"), by="days")
  fall2019    <- seq(as.Date("2019-08-27"), as.Date("2019-12-17"), by="days")
  spring2020  <- seq(as.Date("2020-01-13"), as.Date("2020-05-08"), by="days")
  fall2020    <- seq(as.Date("2020-08-25"), as.Date("2020-12-18"), by="days")
  spring2021  <- seq(as.Date("2021-01-21"), as.Date("2021-05-14"), by="days")
  fall2021    <- seq(as.Date("2021-08-24"), as.Date("2021-12-17"), by="days")
  spring2022  <- seq(as.Date("2022-01-19"), as.Date("2022-05-13"), by="days")
  # could I have sequenced like this for thanksgiving and spring break?
  # sure, but I didn't think of it until after I realized I had 1,000 days to hand-code.
  semesters <-c(fall2016, spring2017, fall2017, spring2018, fall2018, spring2019, fall2019, spring2020, fall2020, spring2021, fall2021, spring2022)
  semesters<-as.Date(semesters, "%Y-%m-%d")
  
  
  
  
  
  # calculations --------------- 
  a <- reactive({input$dates[1]})
  b <- reactive({input$dates[2]})
  # okay. The main course of the lesson. Reactivity. 
  
  # Reactivity is the core of shiny. A reactive element is any element of your code that
  # the user of the app can change. In the case up above with the histogram, it was the
  # binwidth, which was input$bins. 
  
  # Because the date-range input gives a list of two dates that we need to operate on 
  # individually, we must do a subset of them using data[]; the [] is not used commonly
  # in the tidyverse, but it allows us to select elements of a larger vector by order. 
  # so list[1] is the first element of a list and so on. In this case we need date[1] and
  # date[2]. But because their values can change via the user, I need to tell shiny to treat 
  # them as reactive. 
  
  # every shiny input element (sliders, check boxes, etc) automatically generates a reactive
  # element as its input. However, because of what I'm doing here, I need to specify that they
  # are reactive *by hand* and that requires putting them inside this reactive({}) wrapper.
  
  
  date_range <- reactive({seq.Date(a(), b(),1)})
  
  # once I've done that, I can continue to do manipulations on them inside other
  # reactive wrappers until they are ready to become output for the user. 
  
  # something VERY IMPORTANT is going on here though. a and b are data objects--dates
  # from above. However, when I call them from now on, I need to call them as a() and b(). 
  
  # yes, that makes them look more like functions than data objects, which is how they operate,
  # but somewhere in the deep code of how shiny operates, it must be treating them as functions.
  # for our part, it's just a rule of thumb we have to remember. 
  
  # this is only true for elements that you hard-code as reactive({}), but if you forget 
  # it, your code will not work and you will spend a whole hour of your day sitting around
  # trying to figure out why `object of class closure is not able to be coerced to class
  # numeric` and be very frustrated. 
  
  
  tspan <- reactive({
    length(date_range()[date_range() %in% semesters & !date_range() %in% holidays])
  }) # this says, "time span" is equal to the number of dates in date_range, provided that they are 
     # %in% the days of the semester and !not %in% the days of holidays. 
  
  # same is true of date_range. Having defined it in a reactive wrapper, it now must be called 
      # as date_range(), even when using [] to subset, so you get the very funny looking date_range()[]. 
  
  output$dateRangeText  <- renderText({
    paste("Number of Days Between", # write this as text
          paste(as.character(input$dates), collapse = " and "), # put the original dates together
          "excluding school holidays is: ", # write this as text
          tspan() # out put the length of days from above as a reactive value. 
    )
  })
}

shinyApp(ui = ui, server = server)
